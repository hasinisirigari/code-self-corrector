# Safety guardrails - Detect malicious code patterns before execution.


import re
from typing import List, Tuple


# Patterns that indicate potentially dangerous code
MALICIOUS_PATTERNS = [
    # System commands
    (r"\bos\.system\s*\(", "os.system - executes shell commands"),
    (r"\bsubprocess\.", "subprocess - executes external processes"),
    (r"\bcommands\.", "commands - executes shell commands"),
    
    # Code execution
    (r"\beval\s*\(", "eval - executes arbitrary code"),
    (r"\bexec\s*\(", "exec - executes arbitrary code"),
    (r"\bcompile\s*\(", "compile - compiles arbitrary code"),
    (r"\b__import__\s*\(", "__import__ - dynamic imports"),
    
    # File operations (beyond what's needed for algorithms)
    (r"\bopen\s*\([^)]*['\"][wa]", "open with write/append mode"),
    (r"\bshutil\.rmtree", "shutil.rmtree - deletes directories"),
    (r"\bos\.remove\b", "os.remove - deletes files"),
    (r"\bos\.unlink\b", "os.unlink - deletes files"),
    (r"\bos\.rmdir\b", "os.rmdir - deletes directories"),
    (r"\bpathlib.*\.unlink", "pathlib unlink - deletes files"),
    (r"\bpathlib.*\.rmdir", "pathlib rmdir - deletes directories"),
    
    # Network operations
    (r"\bsocket\.", "socket - network operations"),
    (r"\burllib\.", "urllib - network requests"),
    (r"\brequests\.", "requests - HTTP requests"),
    (r"\bhttp\.client", "http.client - HTTP operations"),
    (r"\bftplib\.", "ftplib - FTP operations"),
    
    # User input (could hang in Docker)
    (r"\binput\s*\(", "input - waits for user input"),
    (r"\braw_input\s*\(", "raw_input - waits for user input"),
    
    # Dangerous modules
    (r"\bctypes\.", "ctypes - low-level memory access"),
    (r"\bpickle\.loads?\s*\(", "pickle - unsafe deserialization"),
    (r"\bmarshall\.loads?\s*\(", "marshall - unsafe deserialization"),
]


def check_code_safety(code: str) -> Tuple[bool, List[str]]:
    """
    Check if code contains potentially malicious patterns.
    
    Args:
        code: Python code to check
        
    Returns:
        Tuple of (is_safe, list_of_violations)
    """
    violations = []
    
    for pattern, description in MALICIOUS_PATTERNS:
        if re.search(pattern, code, re.IGNORECASE):
            violations.append(description)
    
    is_safe = len(violations) == 0
    return is_safe, violations


def check_test_integrity(original_tests: str, generated_code: str) -> Tuple[bool, str]:
    """
    Ensure the LLM didn't try to modify or include test cases in its solution.
    
    Args:
        original_tests: The original test code
        generated_code: The code generated by the LLM
        
    Returns:
        Tuple of (is_valid, reason)
    """
    # Check if generated code contains test functions
    if re.search(r"\bdef\s+test_", generated_code):
        return False, "Generated code contains test functions"
    
    # Check if generated code contains pytest imports
    if re.search(r"\bimport\s+pytest\b", generated_code):
        return False, "Generated code imports pytest"
    
    # Check if generated code contains assertions that look like tests
    # (Multiple assert statements outside of a function could indicate test tampering)
    lines = generated_code.split('\n')
    top_level_asserts = 0
    in_function = False
    
    for line in lines:
        stripped = line.strip()
        if stripped.startswith('def '):
            in_function = True
        elif stripped and not line[0].isspace() and not stripped.startswith('#'):
            in_function = False
        
        if not in_function and stripped.startswith('assert '):
            top_level_asserts += 1
    
    if top_level_asserts > 2:
        return False, f"Generated code contains {top_level_asserts} top-level assertions (possible test tampering)"
    
    return True, "OK"


# Test when running directly
if __name__ == "__main__":
    from rich.console import Console
    from rich.table import Table
    
    console = Console()
    
    console.print("\n[bold blue]Testing Safety Guardrails[/bold blue]\n")
    
    # Test cases
    test_cases = [
        ("Safe code", """
def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)
"""),
        ("os.system", """
import os
def run_command(cmd):
    os.system(cmd)
"""),
        ("eval", """
def calculate(expr):
    return eval(expr)
"""),
        ("Network request", """
import requests
def fetch(url):
    return requests.get(url).text
"""),
        ("File write", """
def save(data):
    with open("output.txt", "w") as f:
        f.write(data)
"""),
        ("User input", """
def greet():
    name = input("Enter name: ")
    return f"Hello {name}"
"""),
        ("subprocess", """
import subprocess
def run(cmd):
    subprocess.run(cmd, shell=True)
"""),
    ]
    
    # Create results table
    table = Table(title="Safety Check Results")
    table.add_column("Test Case", style="cyan")
    table.add_column("Safe?", style="green")
    table.add_column("Violations", style="red")
    
    for name, code in test_cases:
        is_safe, violations = check_code_safety(code)
        safe_str = "✓ Yes" if is_safe else "✗ No"
        violations_str = ", ".join(violations) if violations else "-"
        table.add_row(name, safe_str, violations_str)
    
    console.print(table)
    
    # Test integrity check
    console.print("\n[bold]Test Integrity Checks:[/bold]\n")
    
    # Good code
    good_code = """
def add(a, b):
    return a + b
"""
    is_valid, reason = check_test_integrity("", good_code)
    console.print(f"Good code: [green]✓ {reason}[/green]")
    
    # Code with test function
    bad_code = """
def add(a, b):
    return a + b

def test_add():
    assert add(1, 2) == 3
"""
    is_valid, reason = check_test_integrity("", bad_code)
    console.print(f"Code with test: [red]✗ {reason}[/red]")
    
    console.print("\n[bold green]Guardrails test completed![/bold green]")